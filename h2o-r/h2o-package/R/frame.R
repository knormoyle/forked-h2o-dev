#'
#' A Mix of H2O-specific and Overloaded R methods.
#'
#' Below we have a mix of h2o and overloaded R methods according to the following ToC:
#'
#'  H2O Methods:
#'  ------------
#'
#'      h2o.ls, h2o.rm, h2o.assign, h2o.createFrame, h2o.splitFrame, h2o.ignoreColumns, h2o.cut, h2o.table
#'
#'  Time & Date: '*' matches "Frame" and "ParsedData" --> indicates method dispatch via UseMethod
#'  ------------
#'
#'      year.H2O*, month.H2O*, diff.H2O*
#'
#'
#'
#' Methods are grouped according to the data types upon which they operate. There is a grouping of H2O specifc methods
#' and methods that are overloaded from the R language (e.g. summary, head, tail, dim, nrow).
#'
#' Important Developer Notes on the Lazy Evaluators:
#' -------------------------------------------------
#'
#' The H2OFrame "lazy" evaluators: Evaulate an AST.
#'
#' The pattern below is necessary in order to swap out S4 objects *in the calling frame*,
#' and the code re-use is necessary in order to safely assign back to the correct environment (i.e. back to the correct
#' calling scope). If you *absolutely* need to nest calls like this, you _MUST_ correctly track the names all the way down,
#' and then all the way back up the scopes.
#' Here's the example pattern: Number of columns
#'
#' Num Columns of an AST.
#'
#' Evaluate the AST and produce the ncol of the eval'ed AST.
#'
#'       ncol.H2OFrame <- function(x) {
#'         ID  <- as.list(match.call())$x                                    # try to get the ID from the call
#'         if(length(as.list(substitute(x))) > 1) ID <- "Last.value"         # get an appropriate ID
#'         .force.eval(h2o.getConnection(), x, ID = ID, rID = 'x')           # call the force eval
#'         ID <- ifelse(ID == "Last.value", ID, x@@key)                      # bridge the IDs between the force.eval and the parent frame
#'         assign(ID, x, parent.frame())                                     # assign the eval'd frame into the parent env
#'         ncol(get(ID, parent.frame()))                                     # get the object back from the parent and perform the op
#'       }
#'
#' Take this line-by-line:
#'    Line 1: grab the ID from the arg list, this ID is what we want the key to be in H2O
#'    Line 2: if there is no suitable ID (i.e. we have some object, not a named thing), assign to Last.value
#'    Line 3:
#'          1. Get a handle to h2o (h2o.getConnection())
#'          2. x is the ast we want to eval
#'          3. ID is the identifier we want the eventual object to have at the end of the day
#'          4. rID is used in .force.eval to assign back into *this* scope (i.e. child scope -> parent scope)
#'    Line 4: The identifier in the parent scope will either be Last.value, or the key of the H2OFrame
#'             *NB: x is _guaranteed_ to be an H2OFrame object at this point (this is post .force.eval)
#'    Line 5: assign from *this* scope, into the parent scope
#'    Line 6: Do
#' @name MethodsIntro
NULL

#' Data Frame Creation in H2O
#'
#' Creates a data frame in H2O with real-valued, categorical, integer, and binary columns specified by the user.
#'
#' @param conn A \linkS4class{H2OConnection} object.
#' @param key A string indicating the destination key. If empty, this will be auto-generated by H2O.
#' @param rows The number of rows of data to generate.
#' @param cols The number of columns of data to generate. Excludes the response column if \code{has_response = TRUE}.
#' @param randomize A logical value indicating whether data values should be randomly generated. This must be TRUE if either \code{categorical_fraction} or \code{integer_fraction} is non-zero.
#' @param value If \code{randomize = FALSE}, then all real-valued entries will be set to this value.
#' @param real_range The range of randomly generated real values.
#' @param categorical_fraction The fraction of total columns that are categorical.
#' @param factors The number of (unique) factor levels in each categorical column.
#' @param integer_fraction The fraction of total columns that are integer-valued.
#' @param integer_range The range of randomly generated integer values.
#' @param binary_fraction The fraction of total columns that are binary-valued.
#' @param binary_ones_fraction The fraction of values in a binary column that are set to 1.
#' @param missing_fraction The fraction of total entries in the data frame that are set to NA.
#' @param response_factors If \code{has_response = TRUE}, then this is the number of factor levels in the response column.
#' @param has_response A logical value indicating whether an additional response column should be pre-pended to the final H2O data frame. If set to TRUE, the total number of columns will be \code{cols+1}.
#' @param seed A seed used to generate random values when \code{randomize = TRUE}.
#' @return Returns a \linkS4class{H2OFrame} object.
#' @examples
#' library(h2o)
#' localH2O <- h2o.init()
#' hex <- h2o.createFrame(localH2O, rows = 1000, cols = 100, categorical_fraction = 0.1, factors = 5, integer_fraction = 0.5, integer_range = 1, has_response = TRUE)
#' head(hex)
#' summary(hex)
#'
#' hex2 <- h2o.createFrame(localH2O, rows = 100, cols = 10, randomize = FALSE, value = 5, categorical_fraction = 0, integer_fraction = 0)
#' summary(hex2)
h2o.createFrame <- function(conn = h2o.getConnection(), key = "", rows = 10000, cols = 10, randomize = TRUE,
                            value = 0, real_range = 100, categorical_fraction = 0.2, factors = 100,
                            integer_fraction = 0.2, integer_range = 100, binary_fraction = 0.1,
                            binary_ones_fraction = 0.02, missing_fraction = 0.01, response_factors = 2,
                            has_response = FALSE, seed) {
  if(!is(conn, "H2OConnection")) stop("`conn` must be an H2OConnection object")
  .key.validate(key)
  if(!is.numeric(rows)) stop("`rows` must be a positive number")
  if(!is.numeric(cols)) stop("`cols` must be a positive number")
  if(!missing(seed) && !is.numeric(seed)) stop("`seed` must be a numeric value")
  if(!is.logical(randomize)) stop("`randomize` must be TRUE or FALSE")
  if(!is.numeric(value)) stop("`value` must be a numeric value")
  if(!is.numeric(real_range)) stop("`real_range` must be a numeric value")
  if(!is.numeric(categorical_fraction)) stop("`categorical_fraction` must be a numeric value")
  if(!is.numeric(factors)) stop("`factors` must be a numeric value")
  if(!is.numeric(integer_fraction)) stop("`integer_fraction` must be a numeric value")
  if(!is.numeric(integer_range)) stop("`integer_range` must be a numeric value")
  if(!is.numeric(binary_fraction)) stop("`binary_fraction` must be a numeric value")
  if(!is.numeric(binary_ones_fraction)) stop("`binary_ones_fraction` must be a numeric value")
  if(!is.numeric(missing_fraction)) stop("`missing_fraction` must be a numeric value")
  if(!is.numeric(response_factors)) stop("`response_factors` must be a numeric value")
  if(!is.logical(has_response)) stop("`has_response` must be a logical value")

  .cframe.map <- c("key" = "dest")
  parms <- lapply(as.list(match.call(expand.dots = FALSE)[-1L]), eval.parent)
  parms$conn <- NULL
  names(parms) <- lapply(names(parms), function(i) { if( i %in% names(.cframe.map) ) i <- .cframe.map[[i]]; i })

  res <- .h2o.__remoteSend(conn, .h2o.__CREATE_FRAME, method = "POST", .params = parms)
  h2o.getFrame(res$dest$name, conn)
}

h2o.splitFrame <- function(data, ratios = 0.75) {
  if(!is(data, "H2OFrame")) stop("`data` must be an H2OFrame object")
  if(!is.numeric(ratios) || length(ratios) == 0L || any(!is.finite(ratios) | ratios < 0 | ratios > 1))
    stop("`ratios` must be between 0 and 1 exclusive")
  if(sum(ratios) >= 1) stop("sum of ratios must be strictly less than 1")

  res <- .h2o.__remoteSend(data@conn, method="GET", "SplitFrame.json", training_frame = data@key, ratios = .collapse(ratios))
  .h2o.__waitOnJob(conn, .res$job$key$name)

  model.view <- .h2o.__remoteSend(conn, method="GET", paste0(.h2o.__MODELS, "/", .res$job$dest$name))
  splits <- lapply(model.view$models[[1L]]$output$splits,
                   function(l) h2o.getFrame(l$`_key`$name, data@conn, linkToGC = TRUE))
  names(splits) <- paste0("split_", c(ratios, 1 - sum(ratios)))
  splits
}

#h2o.ignoreColumns <- function(data, max_na = 0.2) {
#  if(ncol(data) > .MAX_INSPECT_COL_VIEW)
#    warning(data@key, " has greater than ", .MAX_INSPECT_COL_VIEW, " columns. This may take awhile...")
#  if(missing(data)) stop('Must specify object')
#  if(class(data) != 'H2OFrame') stop('object not a h2o data type')
#  numRows = nrow(data)
#  naThreshold = numRows * max_na
#  cardinalityThreshold = numRows
#
#  res = .h2o.__remoteSend(data@conn, .h2o.__PAGE_SUMMARY2, source=data@key, max_ncols=.Machine$integer.max)
#  columns = res$summaries
#  ignore = sapply(columns, function(col) {
#    if(col$stats$type != 'Enum'){# Numeric Column
#      if(col$stats$min==col$stats$max || col$nacnt >= naThreshold){
#        # If min=max then only one value in entire column
#        # If naCnt is higher than 20% of all entries
#        col$colname
#      }
#    }
#    else { # Categorical Column
#      if(col$stats$cardinality==cardinalityThreshold || col$nacnt >= naThreshold ){
#        # If only entry is a unique entry
#        # If naCnt is higher than 20% of all entries
#        col$colname
#      }
#    }
#  }
#  )
#  unlist(ignore)
#}

#' Cross Tabulation and Table Creation in H2O
#'
#' Uses the cross-classifying factors to build a table of counts at each combination of factor levels.
#'
#' @param x An \linkS4class{H2OFrame} object with at most two integer or factor columns.
#' @param y An \linkS4class{H2OFrame} similar to x, or \code{NULL}.
#' @return Returns a tabulated \linkS4class{H2OFrame} object.
#' @examples
#' library(h2o)
#' localH2O <- h2o.init()
#' prosPath <- system.file("extdata", "prostate.csv", package="h2o")
#' prostate.hex <- h2o.uploadFile(localH2O, path = prosPath, key = "prostate.hex")
#' summary(prostate.hex)
#'
#' # Counts of the ages of all patients
#' head(h2o.table(prostate.hex[,3]))
#' h2o.table(prostate.hex[,3])
#'
#' # Two-way table of ages (rows) and race (cols) of all patients
#' head(h2o.table(prostate.hex[,c(3,4)]))
#' h2o.table(prostate.hex[,c(3,4)])
h2o.table <- function(x, y = NULL) {
  if (!is(x, "H2OFrame")) stop("`x` must be an H2OFrame object")
  if (!is.null(y) && !is(y, "H2OFrame")) stop("`y` must be an H2OFrame object")
  ast <- .h2o.nary_op("table", x, y)
  .force.eval(conn = x@conn, ast = ast@ast)
}


#' Cut H2O Numeric Data to Factor
#'
#' Divides the range of the H2O data into intervals and codes the values according to which interval they fall in. The
#' leftmost interval corresponds to the level one, the next is level two, etc.
#'
#' @name h2o.cut
#' @param x An \linkS4class{H2OFrame} object with numeric columns.
#' @param breaks A numeric vector of two or more unique cut points.
#' @param labels Labels for the levels of the resulting category. By default, labels are constructed sing "(a,b]"
#'        interval notation.
#' @param include.lowest \code{Logical}, indicationg if an 'x[i]' equal to the lowest (or highest, for \code{right =
#'        FALSE} 'breaks' value should be included
#' @param right /code{Logical}, indicating if the intervals should be closed on the right (opened on the left) or vice
#'        versa.
#' @param dig.lab Integer which is used when labels are not given, determines the number of digits used in formatting
#'        the beak numbers.
#' @return Returns an \linkS4class{H2OFrame} object containing the factored data with intervals as levels.
#' @examples
#' library(h2o)
#' localH2O <- h2o.init()
#' irisPath <- system.file("extdata", "iris_wheader.csv", package="h2o")
#' iris.hex <- h2o.uploadFile(localH2O, path = irisPath, key = "iris.hex")
#' summary(iris.hex)
#'
#' # Cut sepal length column into intervals determined by min/max/quantiles
#' sepal_len.cut = cut.H2OFrame(iris.hex$sepal_len, c(4.2, 4.8, 5.8, 6, 8))
#' head(sepal_len.cut)
#' summary(sepal_len.cut)
NULL

#' @rdname h2o.cut
cut.H2OFrame<-
function(x, breaks, labels = NULL, include.lowest = FALSE, right = TRUE, dig.lab = 3) {
  if (!is(x, "H2OFrame")) stop("`x` must be an H2O Frame.")
  if (!is.numeric(breaks) || length(breaks) == 0L || !all(is.finite(breaks)))
    stop("`breaks` must be a numeric vector")
  .h2o.nary_op("cut", x, breaks, labels, include.lowest, right, dig.lab)
}

# `match` or %in% for H2OFrame
setMethod("match", "H2OFrame", function(x, table, nomatch = 0, incomparables = NULL) {
  .h2o.nary_op("match", x, table, nomatch, incomparables)
})

# %in% method
setMethod("%in%", "H2OFrame", function(x, table) match(x, table, nomatch = 0) > 0L)

#-----------------------------------------------------------------------------------------------------------------------
# Time & Date
#-----------------------------------------------------------------------------------------------------------------------

# TODO: s4 year, month impls as well?
#h2o.year <- function(x){
#  if( missing(x) ) stop('must specify x')
#  if( !class(x) == 'H2OFrame' ) stop('x must be an h2o data object')
#  res1 <- .h2o.unary_op('year', x)
#  .h2o.binary_op("-", res1, 1900)
#}
#
#h2o.month <- function(x){
#  if( missing(x) ) stop('must specify x')
#  if( !class(x) == 'H2OFrame' ) stop('x must be an h2o data object')
#  .h2o.unary_op('month', x)
#}
#
#year <- function(x) UseMethod('year', x)
#year.H2OFrame <- h2o.year
#month <- function(x) UseMethod('month', x)
#month.H2OFrame <- h2o.month
#
#diff.H2OFrame <- function(x, lag = 1, differences = 1, ...) {
#  if(!is.numeric(lag)) stop("lag must be numeric")
#  if(!is.numeric(differences)) stop("differences must be numeric")
#
#  expr <- paste("diff(", paste(x@key, lag, differences, sep = ","), ")", sep = "")
#  res <- .h2o.__exec2(x@conn, expr)
#  .newH2OObject("H2OFrame", conn=x@conn, key=res$dest_key, logic=FALSE, finalizers=x@finalizers)
#}


h2o.runif <- function(x, seed = -1) {
  if (!is(x, "H2OFrame")) stop("`data` must be an H2OFrame object")
  if (!is.numeric(seed) || length(seed) != 1L || !is.finite(seed)) stop("`seed` must be an integer >= 0")
  if (seed == -1) seed <- runif(1,1,.Machine$integer.max*100)
  ast <- .h2o.nary_op("h2o.runif", x, seed)
  .newH2OObject("H2OFrame", ast = ast@ast, conn = x@conn, key = .key.make(x@conn, "runif"), finalizers = x@finalizers, linkToGC = TRUE)
}


# runif <- function(n, min=0, max=1, seed=-1) {
#  if(!is.numeric(min)) stop("min must be a single number")
#  if(!is.numeric(max)) stop("max must be a single number")
#  if(length(min) > 1 || length(max) > 1) stop("Unimplemented")
#  if(min > max) stop("min must be a number less than or equal to max")


#' Check H2OFrame columns for factors
#'
#' Determines if any column of an H2OFrame object contains categorical data.
#'
#' @name h2o.anyFactor
#' @param x An \code{\linkS4class{H2OFrame}} object.
#' @return Returns a logical value indicating whether any of the columns in \code{x} are factors.
#' @examples
#' library(h2o)
#' localH2O <- h2o.init()
#' irisPath <- system.file("extdata", "iris_wheader.csv", package="h2o")
#' iris.hex <- h2o.importFile(localH2O, path = irisPath)
#' h2o.anyFactor(iris.hex)
h2o.anyFactor <- function(x) {
  if(!is(x, "H2OFrame")) stop("`x` must be an H2OFrame object")
  ast <- .h2o.unary_op("any.factor", x)
  .force.eval(conn = x@conn, ast = ast@ast)
}

#-----------------------------------------------------------------------------------------------------------------------
# Overloaded Base R Methods
#-----------------------------------------------------------------------------------------------------------------------

#-----------------------------------------------------------------------------------------------------------------------
# Slicing
#-----------------------------------------------------------------------------------------------------------------------

#' Extract or Replace Parts of an H2OFrame Object
#' 
#' Operators to extract or replace parts of H2OFrame objects.
#' 
#' @name H2OFrame-Extract
#' @param x object from which to extract element(s) or in which to replace element(s).
#' @param i,j,... indices specifying elements to extract or replace. Indices are numeric or
#'        character vectors or empty (missing) or will be matched to the names.
#' @param name
#' @param drop
NULL

#' @rdname H2OFrame-Extract
setMethod("[", "H2OFrame", function(x, i, j, ..., drop = TRUE) {
  missingI <- missing(i)
  missingJ <- missing(j)

  if (missingJ) {
    if (missingI)
      return(x)

    if ((nargs() - !missing(drop)) < 3L) {
      j <- i
      missingI <- TRUE
      missingJ <- FALSE
    }
  }

  finalizers <- x@finalizers

  if (missingI)
    rows <- "\"null\""
  else if (is(i, "H2OFrame")) {
    finalizers <- c(finalizers, i@finalizers)
    rows <- .get(i)
  } else if (is(i, "ASTNode"))
    rows <- i
  else
    rows <- .eval(substitute(i), parent.frame())

  if (missingJ)
    cols <- "\"null\""
  else {
    if (is.logical(j))
      j <- which(rep(j, length.out = ncol(x)))
    else if (is.character(j)) {
      j <- match(j, colnames(x))
      if (any(is.na(j)))
        stop("undefined column names specified")
    }
    cols <- .eval(substitute(j), parent.frame())
  }

  op  <- new("ASTApply", op = "[")
  ast <- new("ASTNode", root = op, children = list(.get(x), rows, cols))
  .newH2OObject("H2OFrame", ast = ast, conn = x@conn, key = .key.make(x@conn, "subset"), finalizers = finalizers, linkToGC = TRUE)
})

#' @rdname H2OFrame-Extract
setMethod("$", "H2OFrame", function(x, name) {
  x[[name, exact = FALSE]]
})

#' @rdname H2OFrame-Extract
setMethod("[[", "H2OFrame", function(x, i, exact = TRUE) {
  if(missing(i))
    return(x)
  if(length(i) > 1L)
    stop("`[[` can only select one column")
  if (is.character(i)) {
    if (exact)
      i <- match(i, colnames(x))
    else
      i <- pmatch(i, colnames(x))
  }
  if (is.na(i))
    NULL
  else
    x[,i]
})

subset.H2OFrame <- function(x, subset, select, drop = FALSE, ...) {
  missingSubset <- missing(subset)
  missingSelect <- missing(select)

  if (!missingSubset) {
    env  <- as.environment(x)
    rows <- eval(substitute(subset), env, parent.frame())
  }

  if (!missingSelect) {
    env  <- new.env()
    cnms <- colnames(x)
    for (j in seq_along(x))
      assign(cnms[j], j, env)
    cols <- eval(substitute(select), env, parent.frame())
  }

  if (missingSubset && missingSelect)
    x
  else if (missingSelect)
    x[rows,]
  else if (missingSubset)
    x[,cols]
  else
    x[rows, cols]
}

#-----------------------------------------------------------------------------------------------------------------------
# Assignment Operations: [<-, $<-, [[<-, colnames<-, names<-
#-----------------------------------------------------------------------------------------------------------------------
#' @rdname H2OFrame-Extract
setMethod("[<-", "H2OFrame", function(x, i, j, ..., value) {
  missingI <- missing(i)
  missingJ <- missing(j)

  if(!missingI && !is.numeric(i))
    stop("`i` must be missing or a numeric vector")
  if(!missingJ && !is.numeric(j) && !is.character(j))
    stop("`j` must be missing or a numeric or character vector")
  if(!is(value, "H2OFrame") && !is.numeric(value) && !is.character(value))
    stop("`value` can only be an H2OFrame object or a numeric or character vector")

  if (missingI && missingJ)
    sub <- x
  else if (missingI)
    sub <- x[,j]
  else if (missingJ)
    sub <- x[i,]
  else
    sub <- x[i, j]

  lhs <- .get(sub)
  finalizers <- sub@finalizers
  if (is(value, "H2OFrame")) {
    finalizers <- c(finalizers, value@finalizers)
    rhs <- .get(value)
  } else
    rhs <- .eval(substitute(value), parent.frame(), FALSE)

  op  <- new("ASTApply", op = "=")
  ast <- new("ASTNode", root = op, children = list(lhs, rhs))
  o <- new("H2OFrame", ast = ast, conn = x@conn, key = x@key, finalizers = finalizers)
  .force.eval(conn = o@conn, ast = o@ast, new.assign = FALSE)
  o
})

#' @rdname H2OFrame-Extract
setMethod("$<-", "H2OFrame", function(x, name, value) {
  if(!is.character(name) || length(name) != 1L || !nzchar(name))
    stop("`name` must be a non-empty string")

  idx <- match(name, colnames(x))
  if (is.null(value)) {
    if (is.na(idx))
      res <- x
    else
      res <- x[,-idx]
  } else {
    if (is.na(idx))
      idx <- ncol(x) + 1L
    lhs <- x[,idx]

    finalizers <- lhs@finalizers
    if (is(value, "H2OFrame")) {
      finalizers <- c(finalizers, value@finalizers)
      rhs <- .get(value)
    } else if (is.numeric(value))
      rhs <- .eval(substitute(value), parent.frame(), FALSE)
    else
      stop("`value` can only be an H2OFrame object, numeric or NULL")

    res <- new("ASTNode", root = new("ASTApply", op = "="), children = list(lhs, rhs))
    res <- new("H2OFrame", ast = res, conn = x@conn, key = x@key, finalizers = finalizers)
    .force.eval(conn = res@conn, ast = res@ast, new.assign = FALSE)
    colnames(res)[idx] <- name
  }
  res
})

#' @rdname H2OFrame-Extract
setMethod("[[<-", "H2OFrame", function(x, i, value) {
  if(!is(value, "H2OFrame")) stop("Can only append an H2OFrame to an H2OFrame")
  do.call(`$<-`, list(x = x, name = i, value = value))
})

#' @rdname h2o.colnames
setMethod("colnames<-", signature(x="H2OFrame", value="H2OFrame"),
  function(x, value) {
    if(ncol(value) != ncol(x)) stop("Mismatched number of columns")
    colnames(x) <- value@col_names
    x@col_names <- NA_character_
    x
})

#' @rdname h2o.colnames
setMethod("colnames<-", signature(x="H2OFrame", value="character"),
  function(x, value) {
    if(!all(nzchar(value))) stop("Column names must be of non-zero length")
    else if(any(duplicated(value))) stop("Column names must be unique")
    else if(length(value) != (num = ncol(x))) stop("Must specify a vector of exactly ", num, " column names")
    idxs <- 0L:(ncol(x) - 1L)
    res <- .h2o.nary_op("colnames=", x, idxs, value, .key = x@key)
    .force.eval(conn = res@conn, ast = res@ast, key = res@key, finalizers = c(res@finalizers, x@finalizers), new.assign = FALSE)
})

#' @rdname h2o.colnames
setMethod("names", "H2OFrame", function(x) colnames(x))
#' @rdname h2o.colnames
setMethod("names<-", "H2OFrame", function(x, value) { colnames(x) <- value; x })

#-----------------------------------------------------------------------------------------------------------------------
# Transformation Functions: transform, within
#-----------------------------------------------------------------------------------------------------------------------

#'
#' Transform Columns in an H2OFrame Object.
#'
#' Functions that facilitate column transformations of an \linkS4class{H2OFrame} object.
#'
#' @name transform.H2OFrame
#' @param `_data`, data An \linkS4class{H2OFrame} object.
#' @param expr For \code{within} method, column transformations specified as an expression.
#' @param ... For \code{transform} method, column transformations in the form \code{tag=value}.
#' @seealso \code{\link[base]{transform}}, \code{\link[base]{within}} for the base R methods.
#' @examples
#' library(h2o)
#' localH2O <- h2o.init()
#' iris.hex <- as.h2o(iris, localH2O)
#' transformed1 <- transform(iris.hex,
#'                           Sepal.Ratio = Sepal.Length / Sepal.Width,
#'                           Petal.Ratio = Petal.Length / Petal.Width )
#' transformed1
#' transformed2 <- within(iris.hex,
#'                        {Sepal.Product <- Sepal.Length * Sepal.Width
#'                         Petal.Product <- Petal.Length * Petal.Width
#'                         Sepal.Petal.Ratio <- Sepal.Product / Petal.Product
#'                         Sepal.Length <- Sepal.Width <- NULL
#'                         Petal.Length <- Petal.Width <- NULL
#'                         })
#' transformed2
transform.H2OFrame <- function(`_data`, ...) {
  newcols <- eval(substitute(list(...)), as.environment(`_data`), parent.frame())
  null <- unlist(lapply(newcols, is.null))
  newcols <- newcols[!null]
  null <- names(null)[null]
  keep <- !(colnames(`_data`) %in% null)
  if (!all(keep))
    `_data` <- `_data`[,keep]
  if (length(newcols) > 0L) {
    newnames <- names(newcols)
    for (j in newnames)
      colnames(newcols[[j]]) <- j
    newcols <- do.call(h2o.cbind, unname(newcols))
    overwrite <- newnames %in% colnames(`_data`)
    if (any(overwrite))
      `_data`[,newnames[overwrite]] <- newcols[,overwrite]
    if (!all(overwrite))
      `_data` <- h2o.cbind(`_data`, newcols[,!overwrite])
  }
  `_data`
}

#'
#' @rdname transform.H2OFrame
within.H2OFrame <- function(data, expr, ...) {
  env <- as.environment(data)
  eval(substitute(expr), env, parent.frame())
  null <- unlist(eapply(env, is.null))
  null <- names(null)[null]
  remove(list = null, envir = env)
  newcols <- as.list(env)
  if (length(newcols) == 0L)
    NULL
  else {
    ord <- order(factor(names(newcols), levels = colnames(data)))
    newcols <- newcols[ord]
    for (j in names(newcols))
      colnames(newcols[[j]]) <- j
    do.call(h2o.cbind, unname(newcols))
  }
}

#-----------------------------------------------------------------------------------------------------------------------
# Inspection/Summary Operations
#-----------------------------------------------------------------------------------------------------------------------

#' The Number of Rows/Columns of an H2O Dataset
#'
#' Returns a count of the number of rows or columns in an \code{\linkS4class{H2OFrame}} object.
#'
#' @name h2o.nrow
#' @param x An \linkS4class{H2OFrame} object.
#' @seealso \code{\link{dim}} for all the dimensions. \code{\link[base]{nrow}} for the default R method.
#' @examples
#' library(h2o)
#' localH2O <- h2o.init()
#' irisPath <- system.file("extdata", "iris.csv", package="h2o")
#' iris.hex <- h2o.uploadFile(localH2O, path = irisPath)
#' nrow(iris.hex)
#' ncol(iris.hex)
NULL

#'
#' @rdname h2o.nrow
setMethod("nrow", "H2OFrame", function(x) {
  deparsedExpr <- deparse(substitute(x), width.cutoff = 500L)
  if (!is.null(x@ast) && !.is.eval(x))
    x <- .force.eval(conn = x@conn, ast = x@ast, key = x@key, finalizers = x@finalizers, deparsedExpr = deparsedExpr, env = parent.frame())
  if (is.na(x@nrows))
    x <- h2o.getFrame(x@key, x@conn)
  x@nrows
})

#'
#' @rdname h2o.nrow
setMethod("ncol", "H2OFrame", function(x) {
  deparsedExpr <- deparse(substitute(x), width.cutoff = 500L)
  if (!is.null(x@ast) && !.is.eval(x))
    x <- .force.eval(conn = x@conn, ast = x@ast, key = x@key, finalizers = x@finalizers, deparsedExpr = deparsedExpr, env = parent.frame())
  if (is.na(x@ncols))
    x <- h2o.getFrame(x@key, x@conn)
  x@ncols
})

#'
#' Returns Column Names for a Parsed H2O Data Object.
#'
#' Returns column names for an \linkS4class{H2OFrame} object.
#'
#' @name h2o.colnames
#' @param x An \linkS4class{H2OFrame} object.
#' @seealso \code{\link[base]{colnames}} for the base R method.
#' @examples
#' library(h2o)
#' localH2O <- h2o.init()
#' irisPath <- system.file("extdata", "iris.csv", package="h2o")
#' iris.hex <- h2o.uploadFile(localH2O, path = irisPath)
#' summary(iris.hex)
#' colnames(iris.hex)
NULL

#' @rdname h2o.colnames
setMethod("colnames", "H2OFrame", function(x) {
  deparsedExpr <- deparse(substitute(x), width.cutoff = 500L)
  if (!is.null(x@ast) && !.is.eval(x))
    x <- .force.eval(conn = x@conn, ast = x@ast, key = x@key, finalizers = x@finalizers, deparsedExpr = deparsedExpr, env = parent.frame())
  if (is.na(x@col_names[1L]))
    x <- h2o.getFrame(x@key, x@conn)
  x@col_names
})


#' @rdname h2o.colnames
setMethod("names", "H2OFrame", function(x) {
  deparsedExpr <- deparse(substitute(x), width.cutoff = 500L)
  if (!is.null(x@ast) && !.is.eval(x))
    x <- .force.eval(conn = x@conn, ast = x@ast, key = x@key, finalizers = x@finalizers, deparsedExpr = deparsedExpr, env = parent.frame())
  if (is.na(x@nrows))
    x <- h2o.getFrame(x@key, x@conn)
  x@col_names
})

#'
#' Returns the Length of a Parsed H2O Data Object.
#'
#' Returns the length of an \code{\linkS4class{H2OFrame}}
#'
#' @name h2o.length
#' @param x An \linkS4class{H2OFrame} object.
#' @seealso \code{\link[base]{length}} for the base R method.
#' @examples
#' localH2O <- h2o.init()
#' irisPath <- system.file("extdata", "iris.csv", package = "h2o")
#' iris.hex <- h2o.uploadFile(localH2O, path = irisPath)
#' length(iris.hex)
NULL

#' @rdname h2o.length
setMethod("length", "H2OFrame", function(x) if (ncol(x) == 1L) nrow(x) else ncol(x))

#'
#' Returns the Dimensions of a Parsed H2O Data Object.
#'
#' Returns the number of rows and columns for an \linkS4class{H2OFrame} object.
#'
#' @name h2o.dim
#' @param x An \linkS4class{H2OFrame} object.
#' @seealso \code{\link[base]{dim}} for the base R method.
#' @examples
#' localH2O <- h2o.init()
#' irisPath <- system.file("extdata", "iris.csv", package="h2o")
#' iris.hex <- h2o.uploadFile(localH2O, path = irisPath)
#' dim(iris.hex)
setMethod("dim", "H2OFrame", function(x) c(nrow(x), ncol(x)))

#'
#' Return the Head or Tail of an H2O Dataset.
#'
#' Returns the first or last rows of an H2O parsed data object.
#'
#' @name h2o.head
#' @param x An \linkS4class{H2OFrame} object.
#' @param n (Optional) A single integer. If positive, number of rows in x to return. If negative, all but the n first/last number of rows in x.
#' @param ... Arguments to be passed to or from other methods. ##(Currently unimplemented).
#' @return A data frame containing the first or last n rows of an \linkS4class{H2OFrame} object.
#' @examples
#' library(h2o)
#' localH2O <- h2o.init(ip = "localhost", port = 54321, startH2O = TRUE)
#' ausPath <- system.file("extdata", "australia.csv", package="h2o")
#' australia.hex <- h2o.uploadFile(localH2O, path = ausPath)
#' head(australia.hex, 10)
#' tail(australia.hex, 10)
NULL

#'
#' @rdname h2o.head
setMethod("head", "H2OFrame", function(x, n = 6L, ...) {
  stopifnot(length(n) == 1L)
  deparsedExpr <- deparse(substitute(x), width.cutoff = 500L)
  ret <- NULL
  if (!is.null(x@ast) && !.is.eval(x))
    ret <- .force.eval(conn = x@conn, ast = x@ast, key = x@key, finalizers = x@finalizers, deparsedExpr = deparsedExpr, env = parent.frame())
  if (!is.null(ret) && is.numeric(ret))
    return(ret)
  numRows <- nrow(x)
  n <- ifelse(n < 0L, max(numRows + n, 0L), min(n, numRows))
  if(n == 0L)
    data.frame()
  else {
    tmp_head <- x[1:n,]  # seq_len unimpl
    x.slice <- as.data.frame(tmp_head)
    h2o.rm(tmp_head@key, tmp_head@conn)
    x.slice
  }
})

#'
#'  @rdname h2o.head
setMethod("tail", "H2OFrame", function(x, n = 6L, ...) {
  stopifnot(length(n) == 1L)
  deparsedExpr <- deparse(substitute(x), width.cutoff = 500L)
  if (!is.null(x@ast) && !.is.eval(x))
    .force.eval(conn = x@conn, ast = x@ast, key = x@key, finalizers = x@finalizers, deparsedExpr = deparsedExpr, env = parent.frame())

  endidx <- nrow(x)
  n <- ifelse(n < 0L, max(endidx + n, 0L), min(n, endidx))
  if(n == 0L)
    data.frame()
  else {
    startidx <- max(1L, endidx - n)
    idx <- startidx:endidx
    tmp_tail <- x[startidx:endidx,]
    x.slice <- as.data.frame(tmp_tail)
    h2o.rm(tmp_tail@key, tmp_tail@conn)
    rownames(x.slice) <- idx
    x.slice
  }
})

#'
#' The H2OFrame "lazy" evaluators: Evaulate an AST.
#'
#' The pattern below is necessary in order to swap out S4 objects *in the calling frame*,
#' and the code re-use is necessary in order to safely assign back to the correct environment (i.e. back to the correct
#' calling scope).
#' @name LazyEval
NULL

#setMethod("levels", "H2OFrame", function(x) {
#  if(ncol(x) != 1) return(NULL)
#  res = .h2o.__remoteSend(x@conn, .h2o.__HACK_LEVELS2, source = x@key, max_ncols = .Machine$integer.max)
#  res$levels[[1]]
#})

#'
#' Is H2O Data Frame column a enum
#'
#' Returns Boolean.
setMethod("is.factor", "H2OFrame", function(x) {
  res <- .h2o.unary_op("is.factor", x)
  .force.eval(conn = res@conn, ast = res@ast)
})

#'
#' Quantiles of H2O Data Frame.
#'
#' Obtain and display quantiles for H2O parsed data.
#'
#' \code{quantile.H2OFrame}, a method for the \code{\link{quantile}} generic. Obtain and return quantiles for
#' an \code{\linkS4class{H2OFrame}} object.
#'
#' @name quantile
#' @param x An \code{\linkS4class{H2OFrame}} object with a single numeric column.
#' @param probs Numeric vector of probabilities with values in [0,1].
#' @return A vector describing the percentiles at the given cutoffs for the \code{\linkS4class{H2OFrame}} object.
#' @examples
#' # Request quantiles for an H2O parsed data set:
#' library(h2o)
#' localH2O <- h2o.init()
#' prosPath <- system.file("extdata", "prostate.csv", package="h2o")
#' prostate.hex <- h2o.uploadFile(localH2O, path = prosPath)
#' # Request quantiles for a subset of columns in an H2O parsed data set
#' quantile(prostate.hex[,3])
#' for(i in 1:ncol(prostate.hex))
#'    quantile(prostate.hex[,i])
quantile.H2OFrame <- function(x,
                     #AUTOGENERATED params
                     probs = c(0.01, 0.05, 0.1, 0.25, 0.333, 0.5, 0.667, 0.75, 0.9, 0.95, 0.99),
                     ...)
{
  parms <- list()

  # verify input parameters
  if (!is(x, "H2OFrame")) stop("`x` must be an H2OFrame object")
  if(ncol(x) != 1L) stop("quantile only operates on a single column")
  if(is.factor(x)) stop("factors are not allowed")
  #if(!na.rm && .h2o.__unary_op("any.na", x)) stop("missing values and NaN's not allowed if 'na.rm' is FALSE")
  if(!is.numeric(probs) || length(probs) == 0L || any(!is.finite(probs) | probs < 0 | probs > 1))
    stop("`probs` must be between 0 and 1 exclusive")
  #if(type != 2 && type != 7) stop("type must be either 2 (mean interpolation) or 7 (linear interpolation)")
  #if(type != 7) stop("Unimplemented: Only type 7 (linear interpolation) is supported from the console")

  parms <- as.list(match.call()[-1L])

  training_frame <- x
  .quantile.map <- c("x" = "training_frame")
  names(parms) <- lapply(names(parms), function(i) { if( i %in% names(.quantile.map) ) i <- .quantile.map[[i]]; i })

  model <- .h2o.createModel(x@conn, "quantile", parms, parent.frame())

  col <- model@model$quantile[[1L]]
  names(col) <- paste0(100*probs, "%")
  col
}

#'
#' Summarizes the columns of a H2O data frame.
#'
#' A method for the \code{\link{summary}} generic. Summarizes the columns of an H2O data frame or subset of 
#' columns and rows using vector notation (e.g. dataset[row, col])
#'
#' @name summary
#' @param object An \linkS4class{H2OFrame} object.
#' @param ... Arguments to be passed to or from other methods. ##(Currently unimplemented).
#' @return A table displaying the minimum, 1st quartile, median, mean, 3rd quartile and maximum for each 
#' numeric column, and the levels and category counts of the levels in each categorical column. 
#' @examples
#' library(h2o)
#' localH2O = h2o.init()
#' prosPath = system.file("extdata", "prostate.csv", package="h2o")
#' prostate.hex = h2o.importFile(localH2O, path = prosPath)
#' summary(prostate.hex)
#' summary(prostate.hex$GLEASON)
#' summary(prostate.hex[,4:6])
setMethod("summary", "H2OFrame", function(object, ...) {
  digits <- 12L
  cnames <- colnames(object)
  cols <- sapply(cnames, function(x) {
      res <- .h2o.__remoteSend(object@conn, .h2o.__COL_SUMMARY(object@key, x), method = "GET")
      col <- res$frames[[1]]$columns[[1]]
      if(is.null(col$domain)) {
        if(is.null(col$mins) || length(col$mins) == 0) col$mins = NaN
        if(is.null(col$maxs) || length(col$maxs) == 0) col$maxs = NaN
        if(is.null(col$mean)) col$mean = NaN
        if(is.null(col$pctiles))
          params <- format(rep(signif(as.numeric(col$mean), digits), 6), digits = 4)
        else
          params = format(signif(as.numeric(c(col$mins[1], col$pctiles[3], col$pctiles[5], col$mean, col$pctile[7], col$maxs[5])), digits), digits = 4)
        c(paste0("Min.   :", params[1], "  "), paste0("1st Qu.:", params[2], "  "),
          paste0("Median :", params[3], "  "), paste0("Mean   :", params[4], "  "),
          paste0("3rd Qu.:", params[5], "  "), paste0("Max.   :", params[6], "  "))
      } else {
        top.ix <- sort.int(col$bins, decreasing = TRUE, index.return = TRUE)$ix[1:6]
        if(is.null(col$domain)) domains <- top.ix[1:6] else domains <- col$domain[top.ix]
        counts <- col$bins[top.ix]
        
        # TODO: Make sure "NA's" isn't a legal domain level.
        if(!is.null(col$missing) && col$missing > 0) {
          idx <- ifelse(any(is.na(top.ix)), which(is.na(top.ix))[1], 6)
          domains[idx] <- "NA's"
          counts[idx] <- col$missing
        }
        
        width <- c(max(nchar(domains)), max(nchar(counts)))
        result <- paste0(domains,
                        sapply(domains, function(x) { ifelse(width[1] == nchar(x), "", paste(rep(' ', width[1] - nchar(x)), collapse='')) }),
                          ":",
                        sapply(counts, function(y) { ifelse(width[2] == nchar(y), "", paste(rep(' ', width[2] - nchar(y)), collapse='')) }),
                          counts, " ")
        result[is.na(domains)] <- NA
        result
      }
    })
  
  # Filter out rows with nothing in them
  cidx <- apply(cols, 1, function(x) { any(!is.na(x)) })
  if(ncol(cols) == 1) { cols <- as.matrix(cols[cidx,]) } else { cols <- cols[cidx,] }

  result = as.table(cols)
  rownames(result) <- rep("", nrow(result))
  colnames(result) <- cnames
  result
})

#-----------------------------------------------------------------------------------------------------------------------
# Summary Statistics Operations
#-----------------------------------------------------------------------------------------------------------------------

#'
#' Mean of a column
#'
#' Obtain the mean of a column of a parsed H2O data object.
#'
#' @name h2o.mean
#' @param x An \linkS4class{H2OFrame} object.
#' @param trim The fraction (0 to 0.5) of observations to trim from each end of \code{x} before the mean is computed.
#' @param na.rm A logical value indicating whether \code{NA} or missing values should be stripped before the computation.
#' @param ... Further arguments to be passed from or to other methods.
#' @seealso \code{\link[base]{mean}} for the base R implementation.
#' @examples
#' localH2O <- h2o.init()
#' prosPath <- system.file("extdata", "prostate.csv", package="h2o")
#' prostate.hex <- h2o.uploadFile(localH2O, path = prosPath)
#' mean(prostate.hex$AGE)
setMethod("mean", "H2OFrame", function(x, trim = 0, na.rm = FALSE, ...) {
  if(ncol(x) != 1L) stop("can only compute the mean of a single column")
  if (trim != 0) stop("unimplemented: trim must be 0", call.=FALSE)
  if (trim < 0) trim <- 0
  if (trim > .5) trim <- .5
  res <- .h2o.nary_op("mean", x, trim, na.rm, ...)
  .force.eval(conn = res@conn, ast = res@ast)
})

#
#" Mode of a enum or int column.
#" Returns single string or int value or an array of strings and int that are tied.
# TODO: figure out funcionality/use for documentation
# h2o.mode <-
# function(x) {
#  if(!is(x, "H2OFrame")) || nrow(x) > 1L) stop('`x` must be a H2OFrame object')
# tabularx = invisible(table(x))
#  maxCount = max(tabularx$Count)
#  modes = tabularx$row.names[tabularx$Count == maxCount]
#  return(unlist(as.list(as.matrix(modes))))
#}

#'
#' Variance of a column.
#'
#' Obtain the variance of a column of a parsed H2O data object.
#'
#' @name h2o.var
#' @param x An \linkS4class{H2OFrame} object.
#' @param y \code{NULL} (default) or a column of an \linkS4class{H2OFrame} object. The default is equivalent to y = x (but more efficient).
#' @param na.rm \code{logical}. Should missing values be removed?
#' @param use An optional character string to be used in the presence of missing values. This must be one of the following strings. "everything", "all.obs", or "complete.obs".
#' @seealso \code{\link[stats]{var}} for the base R implementation. \code{\link{h2o.sd}} for standard deviation.
#' @examples
#' localH2O <- h2o.init()
#' prosPath <- system.file("extdata", "prostate.csv", package="h2o")
#' prostate.hex <- h2o.uploadFile(localH2O, path = prosPath)
#' var(prostate.hex$AGE)
setMethod("var", "H2OFrame",
          function(x, y = NULL, na.rm = FALSE, use) {
  if(!missing(use)) {
    if (use %in% c("pairwise.complete.obs", "na.or.complete"))
      stop("Unimplemented : `use` may be either \"everything\", \"all.obs\", or \"complete.obs\"")
  } else
    use <- "everything"
  res <- .h2o.nary_op("var", x, y, na.rm, use)
  .force.eval(conn = res@conn, ast = res@ast)
})

#'
#' Standard Deviation of a column of data.
#'
#' Obtain the standard deviation of a column of data.
#'
#' @name h2o.sd
#' @param x An \linkS4class{H2OFrame} object.
#' @param na.rm \code{logical}. Should missing values be removed?
#' @seealso \code{\link{h2o.var}} for variance, and \code{\link[stats]{sd}} for the base R implementation.
#' @examples
#' localH2O <- h2o.init()
#' prosPath <- system.file("extdata", "prostate.csv", package="h2o")
#' prostate.hex <- h2o.uploadFile(localH2O, path = prosPath)
#' sd(prostate.hex$AGE)
setMethod("sd", "H2OFrame", function(x, na.rm = FALSE) {
  if(ncol(x) != 1L) stop("can only compute sd of a single column.")
  res <- .h2o.nary_op("sd", x, na.rm)
  .force.eval(conn = res@conn, ast = res@ast)
})

#'
#' Scaling and Centering of an H2O Key
#'
#' Centers and/or scales the columns of an H2O dataset.
#'
#' @name h2o.scale
#' @param x An \linkS4class{H2OFrame} object.
#' @param center either a \code{logical} value or numeric vector of length equal to the number of columns of x.
#' @param scale either a \code{logical} value or numeric vector of length equal to the number of columns of x.
#' @examples
#' library(h2o)
#' localH2O <- h2o.init()
#' irisPath <- system.file("extdata", "iris_wheader.csv", package="h2o")
#' iris.hex <- h2o.uploadFile(localH2O, path = irisPath, key = "iris.hex")
#' summary(iris.hex)
#'
#' # Scale and center all the numeric columns in iris data set
#' h2o.scale(iris.hex[, 1:4])
scale.H2OFrame<-
function(x, center = TRUE, scale = TRUE) {
  res <- .h2o.nary_op("scale", x, center, scale)
  .force.eval(conn = res@conn, ast = res@ast)
}

#-----------------------------------------------------------------------------------------------------------------------
# Casting Operations: as.data.frame, as.factor,
#-----------------------------------------------------------------------------------------------------------------------

#'
#' R data.frame -> H2OFrame
#'
#' Import a local R data frame to the H2O cloud.
#'
#' @param object An \code{R} data frame.
#' @param conn An \linkS4class{H2OConnection} object containing the IP address and port number
#' of the H2O server.
#' @param key A string with the desired name for the H2O key.
as.h2o <- function(object, conn = h2o.getConnection(), key = "") {
  if (is(object, "H2OConnection")) {
    temp <- object
    object <- conn
    conn <- temp
  }
  if(!is(conn, "H2OConnection")) stop("`conn` must be a H2OConnection object")
  .key.validate(key)

  # TODO: Be careful, there might be a limit on how long a vector you can define in console
  if(!is.data.frame(object)) {
    object <- as.data.frame(object)
  }
  tmpf <- tempfile(fileext = ".csv")
  write.csv(object, file = tmpf, quote = TRUE, row.names = FALSE, na = "")
  h2f <- h2o.uploadFile(conn, tmpf, key = key)
  file.remove(tmpf)
  h2f
}

#'
#' Converts a Parsed H2O data into a Data Frame
#'
#' Downloads the H2O data and then scan it in to an R data frame.
#'
#' @param x An \linkS4class{H2OFrame} object.
#' @param ... Further arguments to be passed down from other methods.
#' @examples
#' localH2O <- h2o.init()
#' prosPath <- system.file("extdata", "prostate.csv", package="h2o")
#' prostate.hex <- h2o.uploadFile(localH2O, path = prosPath)
#' as.data.frame.H2OFrame(prostate.hex)
as.data.frame.H2OFrame <- function(x, ...) {
  deparsedExpr <- deparse(substitute(x), width.cutoff = 500L)
   if (!is.null(x@ast) && !.is.eval(x))
     .force.eval(conn = x@conn, ast = x@ast, key = x@key, finalizers = x@finalizers, deparsedExpr = deparsedExpr, env = parent.frame())

  # Versions of R prior to 3.1 should not use hex string.
  # Versions of R including 3.1 and later should use hex string.
  use_hex_string <- getRversion() >= "3.1"

  url <- paste0('http://', x@conn@ip, ':', x@conn@port,
                '/2/DownloadDataset',
                '?key=', URLencode(x@key),
                '&hex_string=', as.numeric(use_hex_string))

  ttt <- getURL(url)
  n <- nchar(ttt)

  # Delete last 1 or 2 characters if it's a newline.
  # Handle \r\n (for windows) or just \n (for not windows).
  chars_to_trim <- 0L
  if (n >= 2L) {
      c <- substr(ttt, n, n)
      if (c == "\n") {
          chars_to_trim <- chars_to_trim + 1L
      }
      if (chars_to_trim > 0L) {
          c <- substr(ttt, n-1L, n-1L)
          if (c == "\r") {
              chars_to_trim <- chars_to_trim + 1L
          }
      }
  }

  if (chars_to_trim > 0L) {
    ttt2 <- substr(ttt, 1L, n-chars_to_trim)
    # Is this going to use an extra copy?  Or should we assign directly to ttt?
    ttt <- ttt2
  }

  # Substitute NAs for blank cells rather than skipping
  df <- read.csv((tcon <- textConnection(ttt)), blank.lines.skip = FALSE, ...)
  # df <- read.csv(textConnection(ttt), blank.lines.skip = FALSE, colClasses = colClasses, ...)
  close(tcon)
  df
}


#' Converts H2O Data to an R Matrix
#'
#' Convert an \linkS4class{H2OFrame} object to a matrix, which allows subsequent data frame operations within the R environment.
#'
#' @name as.matrix.h2o
#' @param x An \linkS4class{H2OFrame} object
#' @param \dots Additional arguments to be passed to or from
#' @return Returns a matrix in the R enviornment.
#' @note This call establishes the data set in the R environment and subsequent operations on the matrix take place
#'       within R, not H2O. When data are large, users may experience significant slowdown.
#' @seealso \code{\link[base]{as.matrix}} for the base \code{R} implementation.
#' @examples
#' library(h2o)
#' localH2O <- h2o.init()
#' prosPath <- system.file("extdata", "prostate.csv", package="h2o")
#' prostate.hex <- h2o.uploadFile(localH2O, path = prosPath)
#' prostate.matrix <- as.matrix(prostate.hex)
#' summary(prostate.matrix)
#' head(prostate.matrix)
NULL # TODO: possibly find cleaner method to show 'as.matrix' base is usable with H2OFrame/Frame

#' @rdname as.matrix.h2o
as.matrix.H2OFrame <- function(x, ...) as.matrix(as.data.frame(x, ...))

setMethod("as.environment", "H2OFrame", function(x) {
  env <- new.env()
  for (j in colnames(x))
    assign(j, x[[j]], env)
  env
})

setMethod("as.factor",    "H2OFrame", function(x) .h2o.unary_op("as.factor", x))
setMethod("as.character", "H2OFrame", function(x) .h2o.unary_op("as.character", x))

#-----------------------------------------------------------------------------------------------------------------------
# Merge Operations: ifelse, cbind, rbind, merge
#-----------------------------------------------------------------------------------------------------------------------

setMethod("ifelse", signature(test="H2OFrame", yes="ANY", no="ANY"), function(test, yes, no)
  .h2o.nary_op("ifelse", test, yes, no))

#' Combine H2O Datasets by Columns
#'
#' Takes a sequence of H2O data sets and combines them by column
#'
#' @name h2o.cbind
#' @param \dots A sequence of \linkS4class{H2OFrame} arguments. All datasets must exist on the same H2O instance
#'        (IP and port) and contain the same number of rows.
#' @param deparse.level Integer controlling the construction of column names. ##Currently unimplemented.##
#' @return An \linkS4class{H2OFrame} object containing the combined \dots arguments column-wise.
#' @seealso \code{\link[base]{cbind}} for the base \code{R} method.
#' @examples
#' library(h2o)
#' localH2O <- h2o.init()
#' prosPath <- system.file("extdata", "prostate.csv", package="h2o")
#' prostate.hex <- h2o.uploadFile(localH2O, path = prosPath)
#' prostate.cbind <- h2o.cbind(prostate.hex, prostate.hex)
#' head(prostate.cbind)
NULL

#' @rdname h2o.cbind
h2o.cbind <- function(...) {
  klasses <- unlist(lapply(list(...), function(l) is(l, "H2OFrame")))
  if (any(!klasses)) stop("`h2o.cbind` accepts only of H2OFrame objects")
  .h2o.nary_op("cbind", ...)
}

#' Combine H2O Datasets by Rows
#'
#' Takes a sequence of H2O data sets and combines them by rows
#'
#' @name h2o.rbind
#' @param \dots A sequence of \linkS4class{H2OFrame} arguments. All datasets must exist on the same H2O instance
#'        (IP and port) and contain the same number of rows.
#' @param deparse.level Integer controlling the construction of column names. ##Currently unimplemented.##
#' @return An \linkS4class{H2OFrame} object containing the combined \dots arguments column-wise.
#' @seealso \code{\link[base]{rbind}} for the base \code{R} method.
#' @examples
#' library(h2o)
#' localH2O <- h2o.init()
#' prosPath <- system.file("extdata", "prostate.csv", package="h2o")
#' prostate.hex <- h2o.uploadFile(localH2O, path = prosPath)
#' prostate.cbind <- h2o.rbind(prostate.hex, prostate.hex)
#' head(prostate.cbind)
NULL

#' @rdname h2o.rbind
h2o.rbind <- function(...) {
  l <- unlist(list(...))
  if (is.list(l)) {
    klazzez <- unlist(lapply(l, function(i) is(i, "H2OFrame")))
    if (any(!klazzez)) stop("`h2o.rbind` accepts only of H2OFrame objects")
    .h2o.nary_op("rbind", .args=l)
  } else {
    klasses <- unlist(lapply(list(...), function(l) is(l, "H2OFrame")))
    if (any(!klasses)) stop("`h2o.rbind` must consist of H2O objects only.")
    .h2o.nary_op("rbind", ...)
  }
}


#-----------------------------------------------------------------------------------------------------------------------
# *ply methods: ddply, apply, lapply, sapply,
#-----------------------------------------------------------------------------------------------------------------------

# TODO: Cleanup the cruft!
#' Split H2O Dataset, Apply Function, and Return Results
#'
#' For each subset of an H2O data set, apply a user-specified function, then comine the results.
#'
#' @param .data An \linkS4class{H2OFrame} object to be processed.
#' @param .variables Variables to split \code{.data} by, either the indices or names of a set of columns.
#' @param .fun Function to apply to each subset grouping.
#' @param \dots Additional arguments passed on to \code{.fun}. #TODO: (Currently unimplemented)
#' @param .progress Name of the progress bar to use. #TODO: (Currently unimplemented)
#' @return Returns a \linkS4class{H2OFrame} object containing the results from the split/apply operation, arranged
#          row-by-row
#' @seealso \code{\link[plyr]{ddply}} for the plyr library implementation.
#' @examples
#' library(h2o)
#' localH2O <- h2o.init()
#'
#' # Import iris dataset to H2O
#' irisPath <- system.file("extdata", "iris_wheader.csv", package = "h2o")
#' iris.hex <- h2o.uploadFile(localH2O, path = irisPath, key = "iris.hex")
#' # Add function taking mean of sepal_len column
#' fun = function(df) { sum(df[,1], na.rm = T)/nrow(df) }
#' # Apply function to groups by class of flower
#' # uses h2o's ddply, since iris.hex is an H2OFrame object
#' res = h2o.ddply(iris.hex, "class", fun)
#' head(res)
h2o.ddply <- function (.data, .variables, .fun = NULL, ..., .progress = 'none') {
  mm <- match.call()
  envir <- parent.frame()
  if(!is(.data, "H2OFrame")) stop('.data must be an H2OFrame object')

  # we accept eg .(col1, col2), c('col1', 'col2'), 1:2, c(1,2)
  # as column names.  This is a bit complicated
  if(is.character(.variables)) {
    vars <- match(.variables, colnames(.data))
    if (is.na(vars))
      stop('No column named ', .variables, ' in ', substitute(.data), '.')
  } else if(is(.variables, 'H2Oquoted')) {
    vars <- match(.variables, colnames(.data))
  } else if(inherits(.variables, 'quoted')) { # plyr overwrote our . fn
    vars <- match(.variables, colnames(.data))
  } else if(is.integer(.variables)) {
    vars <- .variables
  } else if(is.numeric(.variables)) {   # this will happen eg c(1,2,3)
    vars <- as.integer(.variables)
  }

  # Change cols from 1 base notation to 0 base notation then verify the column is within range of the dataset
  vars <- vars - 1L
  
  if(vars < 0L || vars > (ncol(.data)-1L))
    stop('Column ', vars, ' out of range for frame columns ', ncol(.data), '.')

  # FUN <- deparse(substitute(.fun), width.cutoff = 500L)
  # if(is.character(.fun)) FUN <- gsub("\"", "", FUN)
  # .FUN <- get(FUN)
  # if( !is.function(.FUN) ) stop("FUN must be an R function
  if( typeof(.fun) == 'closure' ) FUN <- deparse(substitute(.fun), width.cutoff = 500L)
  else FUN <- .fun
  .FUN <- NULL
  if (is.character(FUN)) .FUN <- get(FUN, envir = envir)
  if (!is.null(.FUN) && !is.function(.FUN)) stop("FUN must be an R function")
  else if(is.null(.FUN) && !is.function(FUN))
    stop("FUN must be an R function")
  if (!is.null(.FUN)) FUN <- as.name(FUN)

  l <- list(...)
  if(length(l) > 0L) {
    tmp <- sapply(l, function(x) { !class(x) %in% c("H2OFrame", "numeric", "character", "logical") } )
    if(any(tmp)) stop("H2O only recognizes H2OFrame, numeric, and character objects.")

    idx <- which(sapply(l, function(x) is(x, "H2OFrame")))
    extra_arg_names <- as.list(match.call())
    for (i in vars) {
      key <- as.character(extra_arg_names[[i]])
      if (is(x, "H2OFrame")) next
      x <- l[vars]
      h2o.assign(x, key)
      l[vars] <- x
    }
  }

  # Process the function. Decide if it's an anonymous fcn, or a named one.
  myfun <- deparse(substitute(FUN), width.cutoff = 500L)
  fun.ast <- NULL
  # anon function?
  if (substr(myfun[1L], 1L, nchar("function")) == "function") {
    # handle anon fcn
    fun.ast <- .fun.to.ast(FUN, "anon")
    a <- invisible(.h2o.post.function(fun.ast))
    if (!is.null(a$exception)) stop(a$exception, call.=FALSE)
  # else named function get the ast
  } else {
    if (.is.op(substitute(FUN))) {
      fun.ast <- new("ASTFun", name=myfun, arguments="", body=new("ASTBody", statements=list()))
    } else {
      fun_name <- as.character(FUN)
      fun <- match.fun(FUN)
      fun.ast <- .fun.to.ast(fun, fun_name)
      a <- invisible(.h2o.post.function(fun.ast))
      if (!is.null(a$exception)) stop(a$exception, call.=FALSE)
    }
  }

  if (is.null(fun.ast)) stop("argument FUN was invalid")

#  if(length(l) == 0)
#    ast <- .h2o.nary_op("apply", X, MARGIN, fun.ast)
#  else
#    ast <- .h2o.nary_op("apply", X, MARGIN, fun.ast, fun_args = l)  # see the developer note in ast.R for info on the special "fun_args" parameter
#  ast

#  vars <- paste0('{', paste(vars, collapse = ";"), '}')

  .h2o.nary_op("h2o.ddply", .data, vars, fun.ast)
#  .h2o.nary_op("ddply", .data, vars, .fun, fun_args=list(...), .progress)
}


# TODO: how to avoid masking plyr?
#`h2o..` <- function(...) {
#  mm <- match.call()
#  mm <- mm[-1]
#  structure( as.list(mm), class='H2Oquoted')
#}
#
#`.` <- `h2o..`
#
#h2o.unique <- function(x, incomparables = FALSE, ...) {
#  # NB: we do nothing with incomparables right now
#  # NB: we only support MARGIN = 2 (which is the default)
#
#  if(!class(x) %in% c('H2OFrame', 'H2OFrame', 'H2OFrame')) stop('h2o.unique: x is of the wrong type. Got: ', class(x))
##  if( nrow(x) == 0 | ncol(x) == 0) return(NULL) #TODO: Do this on the back end.
##  if( nrow(x) == 1) return(x)  #TODO: Do this on the back end.
#
#  args <- list(...)
#  if( 'MARGIN' %in% names(args) && args[['MARGIN']] != 2 ) stop('h2o unique: only MARGIN 2 supported')
#  .h2o.unary_op("unique", x)
#}
#unique.H2OFrame <- h2o.unique


#'
#' Overloaded `apply` method from base::
#'
#' `apply` operates on H2OFrames (ASTs or H2OFrame objects) and returns an object of type H2OFrame.
#'
#'
#' Overall Plan:
#'
#'  passes an AST of the format
#'
#'   (apply $X #MARGIN $FUN a1 a2 ...)
#'
#'   ASTApply will parse additional arguments to an AST[] _args. This array must be 1 less the number of args passed to
#'   FUN. Otherwise, throw an exception.
#'
#'   Pass the additional by calling _fun.exec(env, _args)
setMethod("apply", "H2OFrame", function(X, MARGIN, FUN, ...) {
  if(missing(MARGIN) || !(length(MARGIN) <= 2L && all(MARGIN %in% c(1L, 2L))))
    stop("MARGIN must be either 1 (rows), 2 (cols), or a vector containing both")
  if(missing(FUN)) stop("FUN must be an R function")
  .FUN <- NULL
  if (is.character(FUN)) .FUN <- get(FUN)
  if (!is.null(.FUN) && !is.function(.FUN)) stop("FUN must be an R function!")
  else if(is.null(.FUN) && !is.function(FUN))
    stop("FUN must be an R function")
  if (!is.null(.FUN)) FUN <- as.name(FUN)

  l <- list(...)
  if(length(l) > 0L) {
    tmp <- sapply(l, function(x) { !class(x) %in% c("H2OFrame", "numeric", "character", "logical") } )
    if(any(tmp)) stop("H2O only recognizes H2OFrame, numeric, and character objects.")

    idx <- which(sapply(l, function(x) is(x, "H2OFrame")))
    extra_arg_names <- as.list(match.call())
    for (i in idx) {
      key <- as.character(extra_arg_names[[i]])
      if (is(x, "H2OFrame")) next
      x <- l[idx]
      h2o.assign(x, key)
      l[idx] <- x
    }
  }

  # Process the function. Decide if it's an anonymous fcn, or a named one.
  myfun <- deparse(substitute(FUN), width.cutoff = 500L)
  fun.ast <- NULL
  # anon function?
  if (substr(myfun[1L], 1L, nchar("function")) == "function") {
    # handle anon fcn
    fun.ast <- .fun.to.ast(FUN, "anon")
    a <- invisible(.h2o.post.function(fun.ast))
    if (!is.null(a$exception)) stop(a$exception, call.=FALSE)
  # else named function get the ast
  } else {
    if (.is.op(substitute(FUN))) {
      fun.ast <- new("ASTFun", name=myfun, arguments="", body=new("ASTBody", statements=list()))
    } else {
      fun_name <- as.character(FUN)
      fun <- match.fun(FUN)
      fun.ast <- .fun.to.ast(FUN, fun_name)
      a <- invisible(.h2o.post.function(fun.ast))
      if (!is.null(a$exception)) stop(a$exception, call.=FALSE)
    }
  }

  if (is.null(fun.ast)) stop("argument FUN was invalid")

  if(length(l) == 0L)
    .h2o.nary_op("apply", X, MARGIN, fun.ast)
  else
    .h2o.nary_op("apply", X, MARGIN, fun.ast, fun_args = l)  # see the developer note in ast.R for info on the special "fun_args" parameter
})

setMethod("sapply", "H2OFrame", function(X, FUN, ...) {
  if(missing(FUN) || !is.function(FUN))
    stop("FUN must be an R function")

  l <- list(...)
  if(length(l) > 0L) {
      tmp <- sapply(l, function(x) { !class(x) %in% c("H2OFrame", "numeric", "character") } )
      if(any(tmp)) stop("H2O only recognizes H2OFrame, numeric, and character objects.")

    idx <- which(sapply(l, function(x)  is(x, "H2OFrame")))
    extra_arg_names <- as.list(match.call())
    for (i in idx) {
      key <- as.character(extra_arg_names[[i]])
      if (is(x, "H2OFrame")) next
      x <- l[idx]
      h2o.assign(x, key)
      l[idx] <- x
    }
  }

  # Process the function. Decide if it's an anonymous fcn, or a named one.
  myfun <- deparse(substitute(FUN), width.cutoff = 500L)
  fun.ast <- NULL
  # anon function?
  if (substr(myfun[1L], 1L, nchar("function")) == "function") {
    # handle anon fcn
    fun.ast <- .fun.to.ast(FUN, "anon")
    invisible(.h2o.post.function(fun.ast))
  # else named function get the ast
  } else {
    if (.is.op(substitute(FUN))) {
      fun.ast <- new("ASTFun", name=myfun, arguments="", body=new("ASTBody", statements=list()))
    } else {
      fun_name <- as.character(FUN)
      fun <- match.fun(FUN)
      fun.ast <- .fun.to.ast(FUN, fun_name)
      invisible(.h2o.post.function(fun.ast))
    }
  }

  if (is.null(fun.ast)) stop("argument FUN was invalid")

  invisible(.h2o.post.function(fun.ast))

  if(length(l) == 0L)
    .h2o.nary_op("sapply", X, fun.ast)
  else
    .h2o.nary_op("sapply", X, fun.ast, fun_args = l)  # see the developer note in ast.R for info on the special "fun_args" parameter
})

#str.H2OFrame <- function(object, ...) {
#  if (length(l <- list(...)) && any("give.length" == names(l)))
#    invisible(NextMethod("str", ...))
#  else invisible(NextMethod("str", give.length = FALSE, ...))
#
#  if(ncol(object) > .MAX_INSPECT_COL_VIEW)
#    warning(object@key, " has greater than ", .MAX_INSPECT_COL_VIEW, " columns. This may take awhile...")
#  res <- .h2o.__remoteSend(object@conn, .h2o.__PAGE_INSPECT, key=object@key, max_column_display=.Machine$integer.max)
#  cat("\nH2O dataset '", object@key, "':\t", res$num_rows, " obs. of  ", (p <- res$num_cols),
#      " variable", if(p != 1) "s", if(p > 0) ":", "\n", sep = "")
#
#  cc <- unlist(lapply(res$cols, function(y) y$name))
#  width <- max(nchar(cc))
#  rows <- res$rows[1:min(res$num_rows, 10)]    # TODO: Might need to check rows > 0
#
#  if(class(object) == "H2OFrame")
#    res2 <- .h2o.__remoteSend(object@conn, .h2o.__HACK_LEVELS, key=object@key, max_column_display=.Machine$integer.max)
#  else
#    res2 <- .h2o.__remoteSend(object@conn, .h2o.__HACK_LEVELS2, source=object@key, max_ncols=.Machine$integer.max)
#  for(i in 1:p) {
#    cat("$ ", cc[i], rep(' ', width - nchar(cc[i])), ": ", sep = "")
#    rhead <- sapply(rows, function(x) { x[i+1] })
#    if(is.null(res2$levels[[i]]))
#      cat("num  ", paste(rhead, collapse = " "), if(res$num_rows > 10) " ...", "\n", sep = "")
#    else {
#      rlevels <- res2$levels[[i]]
#      cat("Factor w/ ", (count <- length(rlevels)), " level", if(count != 1) "s", ' "', paste(rlevels[1:min(count, 2)], collapse = '","'), '"', if(count > 2) ",..", ": ", sep = "")
#      cat(paste(match(rhead, rlevels), collapse = " "), if(res$num_rows > 10) " ...", "\n", sep = "")
#    }
#  }
#}
#
#setMethod("findInterval", "H2OFrame", function(x, vec, rightmost.closed = FALSE, all.inside = FALSE) {
#  if(any(is.na(vec)))
#    stop("'vec' contains NAs")
#  if(is.unsorted(vec))
#    stop("'vec' must be sorted non-decreasingly")
#  if(all.inside) stop("Unimplemented")
#
#  myVec <- paste0("c(", .seq_to_string(vec), ")")
#  expr <- paste0("findInterval(", x@key, ",", myVec, ",", as.numeric(rightmost.closed), ")")
#  res <- .h2o.__exec2(x@conn, expr)
#  new('H2OFrame', conn=x@conn, key=res$dest_key, finalizers=x@finalizers)
#})
#
## setGeneric("histograms", function(object) { standardGeneric("histograms") })
## setMethod("histograms", "H2OFrame", function(object) {
##   if(ncol(object) > .MAX_INSPECT_COL_VIEW)
##     warning(object@key, " has greater than ", .MAX_INSPECT_COL_VIEW, " columns. This may take awhile...")
##   res <- .h2o.__remoteSend(object@conn, .h2o.__PAGE_SUMMARY2, source=object@key, max_ncols=.Machine$integer.max)
##   list.of.bins <- lapply(res$summaries, function(x) {
##     if (x$stats$type == 'Enum') {
##       bins <- NULL
##     } else {
##       counts <- x$hcnt
##       breaks <- seq(x$hstart, by=x$hstep, length.out=length(x$hcnt) + 1L)
##       bins <- list(counts,breaks)
##       names(bins) <- cbind('counts', 'breaks')
##     }
##     bins
##   })
##   list.of.bins
## })
